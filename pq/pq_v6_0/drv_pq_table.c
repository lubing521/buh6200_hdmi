/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2016-2019. All rights reserved.
 * Description: pq param table
 * Author: pq
 * Create: 2016-01-1
 */

#include "drv_pq.h"
#include "hi_type.h"
#include "drv_pq_tools.h"
#include "pq_hal_table_default.h"

static hi_bool g_is_pq_table_initial = HI_FALSE;
static hi_u32 g_phy_list_num = PHY_REG_MAX;
static hi_u32 g_soft_list_num = SOFT_REG_MAX;
static pq_bin_phy_reg *g_phy_reg = HI_NULL;
static pq_bin_phy_reg *g_soft_reg = HI_NULL;
static hi_pq_bin_module_pos g_bin_pos[HI_PQ_MODULE_MAX];

static pq_mixed_key_reg g_mixed_key_reg_array[PHY_REG_MAX] = { 0 };

static hi_s32 pq_table_calculate_soft_list_num(hi_u32 *soft_reg_num)
{
    hi_u32 i = 0;

    PQ_CHECK_NULL_PTR_RE_FAIL(soft_reg_num);
    PQ_CHECK_NULL_PTR_RE_FAIL(g_soft_reg);

    for (i = 0; i < SOFT_REG_MAX; i++) {
        if ((g_soft_reg[i].reg_addr == 0)
            && (g_soft_reg[i].lsb == 0)
            && (g_soft_reg[i].msb == 0)) {
            break;
        }
    }

    *soft_reg_num = i;
    return HI_SUCCESS;
}

static hi_s32 pq_table_calculate_phy_list_num(hi_u32 *phy_reg_num)
{
    hi_u32 i = 0;

    PQ_CHECK_NULL_PTR_RE_FAIL(phy_reg_num);
    PQ_CHECK_NULL_PTR_RE_FAIL(g_phy_reg);

    for (i = 0; i < PHY_REG_MAX; i++) {
        if ((g_phy_reg[i].reg_addr == 0)
            && (g_phy_reg[i].lsb == 0)
            && (g_phy_reg[i].msb == 0)) {
            break;
        }
    }

    *phy_reg_num = i;
    return HI_SUCCESS;
}

static hi_void pq_table_calculate_position_per_alg(hi_void)
{
    hi_u32 i = 0;
    hi_u32 order = 0;

    PQ_CHECK_NULL_PTR_RE_NULL(g_phy_reg);

    /* init variable about pq table */
    for (i = 0; i < HI_PQ_MODULE_MAX; i++) {
        g_bin_pos[i].start_pos = PHY_REG_MAX - 1;
        g_bin_pos[i].end_pos = 0;
    }

    /* calculate start position and end position of alg module */
    for (i = 0; i < PHY_REG_MAX; i++) {
        if ((g_phy_reg[i].reg_addr == 0)
            && (g_phy_reg[i].lsb == 0)
            && (g_phy_reg[i].msb == 0)) {
            break;
        }

        /* init start position and end position of pq bin module */
        order = g_phy_reg[i].module;
        if (order >= HI_PQ_MODULE_MAX) {
            continue;
        }

        g_bin_pos[order].start_pos = MIN2(g_bin_pos[order].start_pos, i);
        g_bin_pos[order].end_pos = MAX2(g_bin_pos[order].end_pos, i);
    }

    return;
}

hi_s32 pq_table_deinit_pqtable(hi_void)
{
    if (g_is_pq_table_initial != HI_TRUE) {
        return HI_SUCCESS;
    }

    g_is_pq_table_initial = HI_FALSE;

    return HI_SUCCESS;
}

pq_mixed_key_reg *pq_table_get_mixed_key_reg_array(hi_void)
{
    return g_mixed_key_reg_array;
}

hi_s32 pq_table_search_reg_value(pq_mixed_key_reg *mixed_key_reg_array, hi_u32 array_len, hi_u64 key, hi_u32 *value)
{
    hi_u32 mid;
    hi_u32 start;
    hi_u32 end;

    PQ_CHECK_NULL_PTR_RE_FAIL(mixed_key_reg_array);
    PQ_CHECK_NULL_PTR_RE_FAIL(value);
    PQ_CHECK_ZERO_RE_FAIL(array_len);

    start = 0;
    end = array_len - 1;

    while (start <= end) {
        mid = (end - start) / 2 + start; /* 2 is the middle of array. */
        if (key < mixed_key_reg_array[mid].key) {
            end = mid - 1;
        } else if (key > mixed_key_reg_array[mid].key) {
            start = mid + 1;
        } else {
            *value = mixed_key_reg_array[mid].value;
            return HI_SUCCESS;
        }
    }
    /* can not find the key! */
    //HI_WARN_PQ("Can not find the key->%lld.\n", key);
    return HI_FAILURE;
}

hi_s32 pq_table_create_mixed_key_reg_array(pq_mixed_key_reg *mixed_key_reg_array)
{
    hi_u32 i;
    hi_u64 mixed_key;
    pq_bin_phy_reg *phy_reg_default = pq_table_get_phy_reg_default();

    PQ_CHECK_NULL_PTR_RE_FAIL(mixed_key_reg_array);

    /* mixed key is generated by addr(20 bits)/lsb(5 bits)/msb(5 bits)/
     * source_mode(4 bits)/output_mode(4 bits)/module(5bits)
     */
    for (i = 0; i < PHY_REG_MAX; i++) {
        mixed_key = (phy_reg_default[i].reg_addr << 23)   |  /* 23 is 5 + 5 + 4 + 4 + 5 */
                    (phy_reg_default[i].lsb << 18)        |  /* 18 is 5 + 4 + 4 + 5 */
                    (phy_reg_default[i].msb << 13)        |  /* 13 is 4 + 4 + 5 */
                    (phy_reg_default[i].source_mode << 9) |  /* 9  is 4 + 5 */
                    (phy_reg_default[i].output_mode << 5) |  /* 5  is module(5bits) */
                    (phy_reg_default[i].module);
        mixed_key_reg_array[i].key = mixed_key;
        mixed_key_reg_array[i].value = phy_reg_default[i].value;
    }

    return HI_SUCCESS;
}

static hi_void pq_table_mixed_key_reg_swap(pq_mixed_key_reg *mixed_key_reg_a, pq_mixed_key_reg *mixed_key_reg_b)
{
    pq_mixed_key_reg mixed_key_reg_tmp = *mixed_key_reg_b;
    *mixed_key_reg_b = *mixed_key_reg_a;
    *mixed_key_reg_a = mixed_key_reg_tmp;
    return;
}

static hi_void pq_table_mixed_key_reg_heap_adjust(pq_mixed_key_reg *mixed_key_reg_array,
                                                  hi_u32 adjust_location, hi_u32 array_len)
{
    hi_u32 child_index;
    pq_mixed_key_reg temp_mixed_key_reg;

    for (temp_mixed_key_reg = mixed_key_reg_array[adjust_location];
         2 * adjust_location + 1 < array_len; adjust_location = child_index) {  /* 2 is the child node. */
        child_index = 2 * adjust_location + 1;  /* 2 is the child node. */

        if ((child_index != array_len - 1) &&
            (mixed_key_reg_array[child_index + 1].key > mixed_key_reg_array[child_index].key)) {
            child_index += 1;
        }

        if (temp_mixed_key_reg.key < mixed_key_reg_array[child_index].key) {
            mixed_key_reg_array[adjust_location] = mixed_key_reg_array[child_index];
        } else {
            break;
        }
    }

    mixed_key_reg_array[adjust_location] = temp_mixed_key_reg;

    return;
}

hi_s32 pq_table_heap_sort_mixed_key_reg_array(pq_mixed_key_reg *mixed_key_reg_array, hi_u32 array_len)
{
    hi_s32 i;

    PQ_CHECK_NULL_PTR_RE_FAIL(mixed_key_reg_array);

    if (array_len == 0 || array_len > PHY_REG_MAX) {
        HI_ERR_PQ("array_len->%d is invalid!\n", array_len);
        return HI_ERR_PQ_INVALID_PARA;
    }

    /* create a big heap */
    for (i = array_len / 2 - 1; i >= 0; --i) {  /* 2 is the middle array(parent node). */
        pq_table_mixed_key_reg_heap_adjust(mixed_key_reg_array, i, array_len);
    }

    /* sort array */
    for (i = array_len - 1; i > 0; --i) {
        pq_table_mixed_key_reg_swap(&mixed_key_reg_array[0], &mixed_key_reg_array[i]);
        pq_table_mixed_key_reg_heap_adjust(mixed_key_reg_array, 0, i);
    }

    return HI_SUCCESS;
}

hi_s32 pq_table_init_pqtable(pq_bin_param *pq_param, hi_bool pq_para_use_table)
{
    hi_s32 ret;
    if (g_is_pq_table_initial == HI_TRUE) {
        return HI_SUCCESS;
    }

    PQ_CHECK_NULL_PTR_RE_FAIL(pq_param);
    /* get table phy & soft reg value */
    g_phy_reg = pq_param->phy_reg;
    g_soft_reg = pq_param->soft_reg;

    /* if bin failed, use code table para */
    if (pq_para_use_table == HI_TRUE) {
        /* set default pqparam form code */
        pq_table_set_table_reg_default();
    }

    /* each pq module reg start & end pos */
    pq_table_calculate_position_per_alg();

    /* calc how many pq phy & soft module */
    ret = pq_table_calculate_phy_list_num(&g_phy_list_num);
    PQ_CHECK_RETURN_SUCCESS(ret);

    ret = pq_table_calculate_soft_list_num(&g_soft_list_num);
    PQ_CHECK_RETURN_SUCCESS(ret);

    HI_INFO_PQ("phy register num:%u\n", g_phy_list_num);
    HI_INFO_PQ("soft register num:%u\n", g_soft_list_num);

    pq_param->pq_file_header.phy_reg_num = g_phy_list_num;
    pq_param->pq_file_header.soft_reg_num = g_soft_list_num;

    /* set soft reg value */
    ret = pq_table_init_soft_table(HI_TRUE);
    PQ_CHECK_RETURN_SUCCESS(ret);

    /* create mixed key reg array. */
    ret = pq_table_create_mixed_key_reg_array(&g_mixed_key_reg_array[0]);
    PQ_CHECK_RETURN_SUCCESS(ret);
    /* sort mixed key array for search. */
    ret = pq_table_heap_sort_mixed_key_reg_array(&g_mixed_key_reg_array[0], PHY_REG_MAX);
    PQ_CHECK_RETURN_SUCCESS(ret);

    g_is_pq_table_initial = HI_TRUE;

    return HI_SUCCESS;
}

hi_s32 pq_table_set_vdp_reg(hi_u64 addr, hi_u8 lsb, hi_u8 msb, hi_u32 value)
{
    hi_s32 ret = HI_SUCCESS;
    hi_u32 reg_value = 0;
    vdp_regs_type *vdp_reg = HI_NULL;

    if (((addr >= CLE_4K_PARA_REG_START) && (addr <= CLE_4K_PARA_REG_END)) ||
        ((addr >= CLE_8K_PARA_REG_START) && (addr <= CLE_8K_PARA_REG_END))) {
        if (PQ_FUNC_CALL(HI_PQ_MODULE_CLE, cle_ddr_regread)) {
            vdp_reg = pq_hal_get_vdp_set_reg();
            PQ_CHECK_NULL_PTR_RE_FAIL(vdp_reg);

            addr = (uintptr_t)vdp_reg + (addr - VDP_REGS_ADDR);
            ret = GET_ALG_FUN(HI_PQ_MODULE_CLE)->cle_ddr_regread(addr, &reg_value);
            PQ_CHECK_RETURN_SUCCESS(ret);
        }

        pq_hal_set_u32_by_bit(&reg_value, msb, lsb, value);

        if (PQ_FUNC_CALL(HI_PQ_MODULE_CLE, cle_ddr_regwrite)) {
            ret = GET_ALG_FUN(HI_PQ_MODULE_CLE)->cle_ddr_regwrite(addr, reg_value);
            PQ_CHECK_RETURN_SUCCESS(ret);
        }
    } else if ((addr >= SHARP_VIR_REG_START) && (addr <= SHARP_VIR_REG_END)) {
        if (PQ_FUNC_CALL(HI_PQ_MODULE_SHARPNESS, sharp_ddr_regread)) {
            vdp_reg = pq_hal_get_vdp_set_reg();
            PQ_CHECK_NULL_PTR_RE_FAIL(vdp_reg);

            addr = (uintptr_t)vdp_reg + (addr - VDP_REGS_ADDR);
            ret = GET_ALG_FUN(HI_PQ_MODULE_SHARPNESS)->sharp_ddr_regread(addr, &reg_value);
            PQ_CHECK_RETURN_SUCCESS(ret);
        }

        pq_hal_set_u32_by_bit(&reg_value, msb, lsb, value);

        if (PQ_FUNC_CALL(HI_PQ_MODULE_SHARPNESS, sharp_ddr_regwrite)) {
            ret = GET_ALG_FUN(HI_PQ_MODULE_SHARPNESS)->sharp_ddr_regwrite(addr, reg_value);
            PQ_CHECK_RETURN_SUCCESS(ret);
        }
    } else {
        ret = pq_hal_read_register(0, addr, &reg_value);
        PQ_CHECK_RETURN_SUCCESS(ret);

        pq_hal_set_u32_by_bit(&reg_value, msb, lsb, value);
        ret = pq_hal_write_register(0, addr, reg_value);
    }

    return ret;
}

static hi_s32 pq_table_set_vpss_reg_by_handle_id(hi_u32 handle_id, hi_u64 addr, hi_u8 lsb, hi_u8 msb, hi_u32 value)
{
    hi_s32 ret;
    hi_u32 reg_value = 0;

    ret = pq_hal_read_register(handle_id, addr, &reg_value);
    if (ret != HI_SUCCESS) {
        return ret;
    }

    pq_hal_set_u32_by_bit(&reg_value, msb, lsb, value);
    return pq_hal_write_register(handle_id, addr, reg_value);
}

hi_s32 pq_table_set_vpss_reg(hi_u32 addr, hi_u8 lsb, hi_u8 msb, hi_u32 value)
{
    hi_u32 i = 0;

    for (i = 0; i < VPSS_HANDLE_NUM; i++) {
        if (pq_hal_check_vpss_valid(i) == HI_FAILURE) {
            continue;
        }

        pq_table_set_vpss_reg_by_handle_id(i, addr, lsb, msb, value);
    }

    return HI_SUCCESS;
}

hi_s32 pq_table_load_phy_list(pq_reg_type reg_type,
                              pq_source_mode source_mode,
                              pq_output_mode output_mode,
                              hi_u32 handle_id)
{
    hi_s32 ret = HI_SUCCESS;
    hi_u32 i;
    hi_u64 addr;
    hi_u32 value, module;
    hi_u8 lsb, msb, source_mode_tmp, output_mode_tmp;

    PQ_CHECK_NULL_PTR_RE_FAIL(g_phy_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_phy_list_num, PHY_REG_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(reg_type, REG_TYPE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(source_mode, PQ_SOURCE_MODE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(output_mode, PQ_OUTPUT_MODE_MAX);

    for (i = 0; i < g_phy_list_num; i++) {
        addr = g_phy_reg[i].reg_addr;
        value = g_phy_reg[i].value;
        module = g_phy_reg[i].module;
        lsb = g_phy_reg[i].lsb;
        msb = g_phy_reg[i].msb;
        source_mode_tmp = g_phy_reg[i].source_mode;
        output_mode_tmp = g_phy_reg[i].output_mode;

        addr &= REG_OFFSET_ADDR_MASK;

        if ((hi_u32)reg_type != pq_comm_get_alg_type_id(module)) {
            continue;
        }

        if ((source_mode_tmp != PQ_SOURCE_MODE_NO) && (source_mode_tmp != source_mode)) {
            continue;
        }

        if ((output_mode_tmp != PQ_OUTPUT_MODE_NO) && (output_mode_tmp != output_mode)) {
            continue;
        }

        if (REG_TYPE_VPSS == pq_comm_get_alg_type_id(module)) {
            addr |= VPSS_REGS_ADDR;
            ret = pq_table_set_vpss_reg_by_handle_id(handle_id, addr, lsb, msb, value);
        } else if (REG_TYPE_VDP == pq_comm_get_alg_type_id(module)) {
            addr |= VDP_REGS_ADDR;
            ret = pq_table_set_vdp_reg(addr, lsb, msb, value);
        }

        PQPRINT(PQ_PRN_TABLE, "load_phy_list,load addr:0x%x, source_mode:%d, output_mode:%d, module:%d\n", addr,
                source_mode_tmp, output_mode_tmp, module);
    }

    return ret;
}

hi_s32 pq_table_load_alg_phy_list(hi_pq_module_type module,
                                  pq_source_mode source_mode,
                                  pq_output_mode output_mode)
{
    hi_s32 ret = HI_SUCCESS;
    hi_u32 i;
    hi_u64 addr;
    hi_u32 value;
    hi_u32 module_tmp = 0;
    hi_u32 start_pos;
    hi_u32 end_pos;
    hi_u8 lsb;
    hi_u8 msb;
    hi_u8 source_mode_tmp;
    hi_u8 output_mode_tmp;

    PQ_CHECK_NULL_PTR_RE_FAIL(g_phy_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_phy_list_num, PHY_REG_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(module, HI_PQ_MODULE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(source_mode, PQ_SOURCE_MODE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(output_mode, PQ_OUTPUT_MODE_MAX);

    start_pos = g_bin_pos[module].start_pos;
    end_pos = g_bin_pos[module].end_pos;
    if (end_pos >= g_phy_list_num) {
        HI_ERR_PQ("end_pos:%u,phy_list_num: %u, pqbin pos error!\n", end_pos, g_phy_list_num);
        return HI_FAILURE;
    }

    for (i = start_pos; i <= end_pos; i++) {
        addr = g_phy_reg[i].reg_addr;
        value = g_phy_reg[i].value;
        source_mode_tmp = g_phy_reg[i].module;
        lsb = g_phy_reg[i].lsb;
        msb = g_phy_reg[i].msb;
        source_mode_tmp = g_phy_reg[i].source_mode;
        output_mode_tmp = g_phy_reg[i].output_mode;

        addr &= REG_OFFSET_ADDR_MASK;

        if ((hi_u32)module != module_tmp) {
            continue;
        }

        if ((source_mode_tmp != PQ_SOURCE_MODE_NO) && (source_mode_tmp != source_mode)) {
            continue;
        }

        if ((output_mode_tmp != PQ_OUTPUT_MODE_NO) && (output_mode_tmp != output_mode)) {
            continue;
        }

        if (REG_TYPE_VPSS == pq_comm_get_alg_type_id(module)) {
            addr |= VPSS_REGS_ADDR;
            ret = pq_table_set_vpss_reg(addr, lsb, msb, value);
        } else if (REG_TYPE_VDP == pq_comm_get_alg_type_id(module)) {
            addr |= VDP_REGS_ADDR;
            ret = pq_table_set_vdp_reg(addr, lsb, msb, value);
        }

        PQPRINT(PQ_PRN_TABLE, "load_phy_list_of_alg,load addr:0x%x, source_mode:%d, output_mode:%d, module:%d\n", addr,
                source_mode_tmp, output_mode_tmp, module_tmp);
    }

    return ret;
}

hi_s32 pq_table_load_multi_list(pq_reg_type reg_type, pq_source_mode source_mode, pq_output_mode output_mode)
{
    hi_s32 ret = HI_SUCCESS;
    hi_pq_module_type module;

    PQ_CHECK_OVER_RANGE_RE_FAIL(reg_type, REG_TYPE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(source_mode, PQ_SOURCE_MODE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(output_mode, PQ_OUTPUT_MODE_MAX);

    for (module = 0; module < HI_PQ_MODULE_MAX; module++) {
        if (PQ_BIN_ADAPT_MULTIPLE != pq_comm_get_alg_adape_type(module)) {
            continue;
        }

        if ((hi_u32)reg_type != pq_comm_get_alg_type_id(module)) {
            continue;
        }

        ret = pq_table_load_alg_phy_list(module, source_mode, output_mode);
    }

    return ret;
}

hi_s32 pq_table_copy_phy_list(pq_bin_phy_reg src_reg, pq_bin_phy_reg *dst_reg)
{
    PQ_CHECK_NULL_PTR_RE_FAIL(dst_reg);

    dst_reg->reg_addr = src_reg.reg_addr;
    dst_reg->value = src_reg.value;
    dst_reg->module = src_reg.module;
    dst_reg->lsb = src_reg.lsb;
    dst_reg->msb = src_reg.msb;
    dst_reg->source_mode = src_reg.source_mode;
    dst_reg->output_mode = src_reg.output_mode;

    return HI_SUCCESS;
}

hi_s32 pq_table_init_phy_list(hi_u32 id,
                              hi_pq_module_type module,
                              pq_source_mode source_mode,
                              pq_output_mode output_mode)
{
    vdp_regs_type *vdp_vir_reg = NULL;
    hi_u32 i;
    pq_bin_phy_reg phy_reg = {0};
    hi_u32 reg_value = 0;
    hi_u32 offset_addr = 0x0;
    hi_u32 start_pos;
    hi_u32 end_pos;

    PQ_CHECK_NULL_PTR_RE_FAIL(g_phy_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_phy_list_num, PHY_REG_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(module, HI_PQ_MODULE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(source_mode, PQ_SOURCE_MODE_MAX);
    PQ_CHECK_OVER_RANGE_RE_FAIL(output_mode, PQ_OUTPUT_MODE_MAX);

    start_pos = g_bin_pos[module].start_pos;
    end_pos = g_bin_pos[module].end_pos;
    if (end_pos >= g_phy_list_num) {
        HI_ERR_PQ("end_pos:%u,phy_list_num: %u, pqbin pos error!\n", end_pos, g_phy_list_num);
        return HI_FAILURE;
    }

    for (i = start_pos; i <= end_pos; i++) {
         pq_table_copy_phy_list(g_phy_reg[i], &phy_reg);
        offset_addr = phy_reg.reg_addr & REG_OFFSET_ADDR_MASK;

        if (((hi_u32)module != phy_reg.module) ||
            ((phy_reg.source_mode != PQ_SOURCE_MODE_NO) && (phy_reg.source_mode != source_mode)) ||
            ((phy_reg.output_mode != PQ_OUTPUT_MODE_NO) && (phy_reg.output_mode != output_mode))) {
            continue;
        }

        if (REG_TYPE_VPSS == pq_comm_get_alg_type_id(module)) {
            pq_table_set_vpss_reg(phy_reg.reg_addr | VPSS_REGS_ADDR, phy_reg.lsb, phy_reg.msb, phy_reg.value);
        } else if (REG_TYPE_VDP == pq_comm_get_alg_type_id(module)) {
            vdp_vir_reg = pq_hal_get_vdp_set_reg();
            PQ_CHECK_NULL_PTR_RE_FAIL(vdp_vir_reg);
            reg_value = *((hi_u32 *)((hi_void *)vdp_vir_reg + offset_addr));
            pq_hal_set_u32_by_bit(&reg_value, phy_reg.msb, phy_reg.lsb, phy_reg.value);
            *(hi_u32 *)((hi_void *)vdp_vir_reg + offset_addr) = reg_value;
        }
    }

    return HI_SUCCESS;
}

hi_u32 pq_table_get_soft_table(hi_u32 lut,
                               pq_source_mode source_mode,
                               pq_output_mode output_mode,
                               hi_u32 default_value)
{
    hi_u32 i;
    hi_u32 addr, value;
    hi_u8 source_mode_tmp, output_mode_tmp;

    PQ_CHECK_NULL_PTR_RE_FAIL(g_soft_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_soft_list_num, SOFT_REG_MAX);

    for (i = 0; i < g_soft_list_num; i++) {
        addr = g_soft_reg[i].reg_addr;
        value = g_soft_reg[i].value;
        source_mode_tmp = g_soft_reg[i].source_mode;
        output_mode_tmp = g_soft_reg[i].output_mode;

        if (HI_FAILURE == pq_hal_is_special_reg(addr)) {
            break;
        }

        if (addr != lut) {
            continue;
        }

        if ((source_mode_tmp != PQ_SOURCE_MODE_NO) && (source_mode_tmp != source_mode)) {
            continue;
        }

        if ((output_mode_tmp != PQ_OUTPUT_MODE_NO) && (output_mode_tmp != output_mode)) {
            continue;
        }

        return value;
    }

    return default_value;
}

hi_void pq_table_process_init_soft_table(hi_u32 addr, hi_u32 value)
{
    hi_u8 value_tmp = value & 0x0ff;
    hi_pq_color_temperature temperature = { PQ_ALG_DEFAULT_VALUE, PQ_ALG_DEFAULT_VALUE, PQ_ALG_DEFAULT_VALUE };

    HI_INFO_PQ("addr:%#x, u8_value:%u\n", addr, value_tmp);

    switch (addr) {
        case PQ_SOFT_COLOR_TEMP_R:
            if (GET_ALG(HI_PQ_MODULE_CSC)
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp) {
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp(HI_PQ_DISPLAY_1, &temperature);
                temperature.red_gain = value;
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp(HI_PQ_DISPLAY_1, &temperature);
            }
            break;
        case PQ_SOFT_COLOR_TEMP_G:
            if (GET_ALG(HI_PQ_MODULE_CSC)
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp) {
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp(HI_PQ_DISPLAY_1, &temperature);
                temperature.green_gain = value;
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp(HI_PQ_DISPLAY_1, &temperature);
            }
            break;
        case PQ_SOFT_COLOR_TEMP_B:
            if (GET_ALG(HI_PQ_MODULE_CSC)
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp
                && GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp) {
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->get_color_temp(HI_PQ_DISPLAY_1, &temperature);
                temperature.blue_gain = value;
                GET_ALG_FUN(HI_PQ_MODULE_CSC)->set_color_temp(HI_PQ_DISPLAY_1, &temperature);
            }
            break;
        default: {
            break;
        }
    }
}

hi_s32 pq_table_init_soft_table(hi_bool init)
{
    hi_u32 i;
    hi_u32 addr, value;
    pq_source_mode source_mode;
    pq_output_mode output_mode;
    hi_pq_module_type module;      /* module */
    pq_common_status pq_status = {0};

    drv_pq_get_pq_status(&pq_status);
    if (init == HI_FALSE) {
        return HI_FAILURE;
    }

    PQ_CHECK_NULL_PTR_RE_FAIL(g_soft_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_soft_list_num, SOFT_REG_MAX);

    for (i = 0; i < g_soft_list_num; i++) {
        addr = g_soft_reg[i].reg_addr;
        value = g_soft_reg[i].value;
        source_mode = g_soft_reg[i].source_mode;
        output_mode = g_soft_reg[i].output_mode;
        module = g_soft_reg[i].module;

        if (HI_FAILURE == pq_hal_is_special_reg(addr)) {
            break;
        }

        pq_table_process_init_soft_table(addr, value);
        pq_comm_set_moudle_ctrl(module, source_mode, output_mode, value);
    }

    return HI_SUCCESS;
}

hi_s32 pq_table_find_bin_pos(hi_pq_module_type module, hi_u32 *start_pos, hi_u32 *end_pos)
{
    PQ_CHECK_OVER_RANGE_RE_FAIL(module, HI_PQ_MODULE_MAX);
    PQ_CHECK_NULL_PTR_RE_FAIL(start_pos);
    PQ_CHECK_NULL_PTR_RE_FAIL(end_pos);

    *start_pos = g_bin_pos[module].start_pos;
    *end_pos = g_bin_pos[module].end_pos;

    return HI_SUCCESS;
}

hi_s32 pq_table_set_table_reg_default(hi_void)
{
    hi_u32 i;
    pq_bin_phy_reg *phy_reg_default = pq_table_get_phy_reg_default();
    pq_bin_phy_reg *soft_reg_default = pq_table_get_soft_reg_default();

    PQ_CHECK_NULL_PTR_RE_FAIL(phy_reg_default);
    PQ_CHECK_NULL_PTR_RE_FAIL(soft_reg_default);
    PQ_CHECK_NULL_PTR_RE_FAIL(g_phy_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_phy_list_num, PHY_REG_MAX);
    PQ_CHECK_NULL_PTR_RE_FAIL(g_soft_reg);
    PQ_CHECK_NUM_OVER_RANGE_RE_FAIL(g_soft_list_num, SOFT_REG_MAX);

    memset(g_phy_reg, 0, sizeof(pq_bin_phy_reg) * PHY_REG_MAX);
    memset(g_soft_reg, 0, sizeof(pq_bin_phy_reg) * SOFT_REG_MAX);

    for (i = 0; i < PHY_REG_MAX; i++) {
        if ((0 == phy_reg_default[i].reg_addr)
            && (0 == phy_reg_default[i].lsb)
            && (0 == phy_reg_default[i].msb)) {
            break;
        }
        g_phy_reg[i] = phy_reg_default[i];
    }

    for (i = 0; i < SOFT_REG_MAX; i++) {
        if ((0 == soft_reg_default[i].reg_addr)
            && (0 == soft_reg_default[i].lsb)
            && (0 == soft_reg_default[i].msb)) {
            break;
        }
        g_soft_reg[i] = soft_reg_default[i];
    }

    return HI_SUCCESS;
}

pq_bin_phy_reg *pq_table_get_phy_reg(hi_void)
{
    return g_phy_reg;
}

pq_bin_phy_reg *pq_table_get_soft_reg(hi_void)
{
    return g_soft_reg;
}

hi_u32 pq_table_get_phy_list_num(hi_void)
{
    return g_phy_list_num;
}

hi_u32 pq_table_get_soft_list_num(hi_void)
{
    return g_soft_list_num;
}
